import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as p,f as n,d as s,g as a,b as l}from"./app-p5c8ryjK.js";const i={};function m(r,t){return l(),p("div",null,[...t[0]||(t[0]=[n('<h1 id="chapter-21-g-methods-for-time-varying-treatments-时间变化处理的g方法" tabindex="-1"><a class="header-anchor" href="#chapter-21-g-methods-for-time-varying-treatments-时间变化处理的g方法"><span>Chapter 21: G-Methods for Time-Varying Treatments（时间变化处理的g方法）</span></a></h1><p>This chapter provides a comprehensive overview of three main g-methods—<strong>the g-formula</strong>, <strong>IP weighting</strong>, and <strong>g-estimation</strong>—and their doubly/multiply robust extensions for estimating causal effects in the presence of time-varying treatments with treatment-confounder feedback. The chapter also addresses the issue of censoring as a time-varying process and generalizes the notion of identification through the &quot;big g-formula&quot;. Below, I summarize all technical, fine, and key points, and provide main formulas in both English and Chinese with standard LaTeX math formatting.</p><hr><h2 id="_1-the-challenge" tabindex="-1"><a class="header-anchor" href="#_1-the-challenge"><span>1. The Challenge</span></a></h2><ul><li><strong>Time-varying treatments</strong> complicate confounding adjustment due to <em>treatment-confounder feedback</em> (i.e., confounders affected by or affecting subsequent treatments).</li><li><strong>Traditional adjustment methods</strong> (e.g., standard regression) fail under feedback: even with no causal effect, they can produce a spurious effect estimate.</li></ul><hr><h2 id="_2-g-methods-overview" tabindex="-1"><a class="header-anchor" href="#_2-g-methods-overview"><span>2. G-Methods Overview</span></a></h2><h3 id="main-idea" tabindex="-1"><a class="header-anchor" href="#main-idea"><span>Main Idea</span></a></h3><ul><li><strong>G-methods</strong> are designed to yield <strong>causally correct estimates</strong> under treatment-confounder feedback by satisfying three <em>identifiability conditions</em>: <ol><li><strong>Sequential exchangeability</strong> (sequential ignorability)</li><li><strong>Positivity</strong></li><li><strong>Consistency</strong></li></ol></li></ul><hr><h2 id="_3-the-g-formula-for-time-varying-treatments" tabindex="-1"><a class="header-anchor" href="#_3-the-g-formula-for-time-varying-treatments"><span>3. The G-Formula for Time-Varying Treatments</span></a></h2><h3 id="a-for-two-time-points" tabindex="-1"><a class="header-anchor" href="#a-for-two-time-points"><span>A. For Two Time Points</span></a></h3><p>Suppose we observe baseline and follow-up treatments <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>A</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A_0, A_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, time-varying confounders <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>L</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>L</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(L_0, L_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, and outcome <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>.</p><p><strong>G-Formula (Static Strategy):</strong><br> [<br> E[Y_{a_0, a_1}] = \\sum_{l_1} E[Y|A_0=a_0, A_1=a_1, L_1=l_1] ; f(l_1|a_0)<br> ]</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>l</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi><msub><mi>a</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(l_1|a_0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> is the distribution of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">L_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> given <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub><mo>=</mo><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">A_0 = a_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> in the study population.</li></ul><p><strong>中文：</strong><br> [<br> E[Y_{a_0, a_1}] = \\sum_{l_1} E[Y|A_0=a_0, A_1=a_1, L_1=l_1] \\cdot P(L_1=l_1|A_0=a_0)<br> ]</p><hr><h3 id="b-for-time-points-and-general-settings" tabindex="-1"><a class="header-anchor" href="#b-for-time-points-and-general-settings"><span>B. For <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> Time Points and General Settings</span></a></h3>',18),s("p",null,[a("["),s("br"),a(" E[Y_{\\bar{a}}] = \\sum_{\\bar{l}} E[Y|\\bar{A} = \\bar{a}, \\bar{L} = \\bar{l}] \\prod_{k=0}^K f(l_k | \\bar{a}"),s("em",{"k-1":""},"{k-1}, \\bar{l}"),a(")"),s("br"),a(" ]")],-1),n('<ul><li>Here, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>A</mi><mo>ˉ</mo></mover><mo>=</mo><mo stretchy="false">(</mo><msub><mi>A</mi><mn>0</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>A</mi><mi>K</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\bar{A} = (A_0,...,A_K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8201em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8201em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>L</mi><mo>ˉ</mo></mover><mo>=</mo><mo stretchy="false">(</mo><msub><mi>L</mi><mn>0</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>L</mi><mi>K</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\bar{L} = (L_0,...,L_K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8201em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8201em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">L</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</li></ul>',1),s("p",null,[s("strong",null,"中文："),s("br"),a(" ["),s("br"),a(" E[Y_{\\bar{a}}] = \\sum_{\\bar{l}} E[Y|\\bar{A}=\\bar{a}, \\bar{L}=\\bar{l}] \\prod_{k=0}^K P(L_k | \\bar{A}"),s("em",{"k-1":""},"{k-1}, \\bar{L}"),a(")"),s("br"),a(" ]")],-1),n('<hr><h4 id="key-points-about-the-g-formula" tabindex="-1"><a class="header-anchor" href="#key-points-about-the-g-formula"><span>Key Points about the G-Formula</span></a></h4><ul><li>The formula <em>standardizes the outcome</em> to the confounder distribution under the intervention.</li><li>The set of confounders included (&quot;history&quot;) is what is needed to achieve conditional exchangeability for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">A_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> (<strong>Fine Point 21.1</strong>).</li><li>The <strong>positivity condition</strong>: There must be observed data supporting all relevant treatment/covariate histories.</li><li>In high-dimensional data, parameter estimation requires plug-in (possibly parametric) models (<strong>parametric g-formula</strong>).</li><li>The formula generalizes to both deterministic (fixed path of treatment) and random (probabilistic) strategies.</li></ul><hr><h4 id="g-formula-density-technical-point-21-1" tabindex="-1"><a class="header-anchor" href="#g-formula-density-technical-point-21-1"><span>G-Formula Density (Technical Point 21.1)</span></a></h4>',5),s("p",null,[a("For outcome "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"Y")]),s("annotation",{encoding:"application/x-tex"},"Y")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.22222em"}},"Y")])])]),a(" and covariates "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"L")]),s("annotation",{encoding:"application/x-tex"},"L")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal"},"L")])])]),a(":"),s("br"),a(" ["),s("br"),a(" f(y|\\bar{a}"),s("em",{"k-1":""},[a("K, \\bar{l}"),s("em",{k:"0"},"K) \\prod"),a("^K f(l_k | \\bar{a}")]),a(", \\bar{l}_{k-1})"),s("br"),a(" ]")],-1),n('<ul><li>Marginalizing over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> yields the density for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> under treatment strategy <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>a</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">\\bar{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5678em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5678em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">a</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">ˉ</span></span></span></span></span></span></span></span></span></span>.</li></ul>',1),s("p",null,[s("strong",null,"中文："),s("br"),a(" 处理结果"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"Y")]),s("annotation",{encoding:"application/x-tex"},"Y")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.22222em"}},"Y")])])]),a("与协变量"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"L")]),s("annotation",{encoding:"application/x-tex"},"L")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal"},"L")])])]),a("的g公式密度为："),s("br"),a(" ["),s("br"),a(" f(y|\\bar{a}"),s("em",{"k-1":""},[a("K, \\bar{l}"),s("em",{k:"0"},"K) \\prod"),a("^K f(l_k | \\bar{a}")]),a(", \\bar{l}_{k-1})"),s("br"),a(" ]")],-1),s("hr",null,null,-1),s("h4",{id:"g-formula-for-random-strategies",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#g-formula-for-random-strategies"},[s("span",null,"G-Formula for Random Strategies")])],-1),s("p",null,[a("["),s("br"),a(" E[Y] = \\sum_{\\bar{a}, \\bar{l}} E[Y|\\bar{A} = \\bar{a}, \\bar{L} = \\bar{l}]"),s("br"),a(" \\prod_{k=0}^K f(l_k | \\bar{a}"),s("em",{"k-1":""},"{k-1}, \\bar{l}"),a(") \\prod_{k=0}^K f_{\\text{int}}(a_k | \\bar{a}_{k-1}, \\bar{l}_k)"),s("br"),a(" ]")],-1),s("p",null,[s("strong",null,"中文："),s("br"),a(" 对于随机策略，g公式为："),s("br"),a(" ["),s("br"),a(" E[Y] = \\sum_{\\bar{a}, \\bar{l}} E[Y|\\bar{A}=\\bar{a}, \\bar{L}=\\bar{l}] \\prod_{k=0}^K P(L_k|\\bar{A}"),s("em",{"k-1":""},"{k-1}, \\bar{L}"),a(") \\prod_{k=0}^K P_{\\text{int}}(A_k|\\bar{A}_{k-1},\\bar{L}_k)"),s("br"),a(" ]")],-1),n('<hr><h3 id="c-technical-fine-points" tabindex="-1"><a class="header-anchor" href="#c-technical-fine-points"><span>C. Technical/Fine Points</span></a></h3><ul><li><strong>Inclusion of Variables is Crucial</strong>: Omitting relevant confounders breaks the identification (removes causal interpretation).</li><li><strong>Component-wise Causal Meaning</strong>: The overall g-formula may be causal, but its pieces may lack causal interpretation (unless in sequentially randomized data).</li><li><strong>&quot;History&quot; Might Not Match Time</strong>: &quot;History&quot; for adjustment is the set of variables required for exchangeability, not necessarily all earlier-in-time variables.</li></ul><hr><h2 id="_4-ip-weighting-for-time-varying-treatments" tabindex="-1"><a class="header-anchor" href="#_4-ip-weighting-for-time-varying-treatments"><span>4. IP Weighting for Time-Varying Treatments</span></a></h2><h3 id="a-definition" tabindex="-1"><a class="header-anchor" href="#a-definition"><span>A. Definition</span></a></h3><p>For treatment history <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>A</mi><mo>ˉ</mo></mover><mo>=</mo><mo stretchy="false">(</mo><msub><mi>A</mi><mn>0</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>A</mi><mi>K</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\bar{A} = (A_0,\\ldots,A_K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8201em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8201em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> and confounder history <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>L</mi><mo>ˉ</mo></mover><mo>=</mo><mo stretchy="false">(</mo><msub><mi>L</mi><mn>0</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>L</mi><mi>K</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\bar{L} = (L_0,...,L_K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8201em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8201em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">L</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, the <strong>Inverse Probability (IP) Weight</strong> at time <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>:</p><p><strong>Non-stabilized weight:</strong><br> [<br> W_{\\bar{A}} = \\prod_{k=0}^K \\frac{1}{f(A_k|\\bar{A}_{k-1}, \\bar{L}_k)}<br> ]</p>',8),s("p",null,[s("strong",null,"Stabilized weight:"),s("br"),a(" ["),s("br"),a(" SW_{\\bar{A}} = \\prod_{k=0}^K \\frac{f(A_k|\\bar{A}"),s("em",{"k-1":""},"{k-1})}{f(A_k|\\bar{A}"),a(", \\bar{L}_k)}"),s("br"),a(" ]")],-1),s("p",null,[s("strong",null,"中文：")],-1),s("p",null,[a("非稳态IP权重："),s("br"),a(" ["),s("br"),a(" W_{\\bar{A}} = \\prod_{k=0}^K \\frac{1}{P(A_k|\\bar{A}_{k-1}, \\bar{L}_k)}"),s("br"),a(" ]")],-1),s("p",null,[a("稳态（稳定化）IP权重："),s("br"),a(" ["),s("br"),a(" SW_{\\bar{A}} = \\prod_{k=0}^K \\frac{P(A_k|\\bar{A}"),s("em",{"k-1":""},"{k-1})}{P(A_k|\\bar{A}"),a(", \\bar{L}_k)}"),s("br"),a(" ]")],-1),n('<hr><h3 id="b-implementation" tabindex="-1"><a class="header-anchor" href="#b-implementation"><span>B. Implementation</span></a></h3><ul><li>Fit models for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>A</mi><mi>k</mi></msub><mi mathvariant="normal">∣</mi><msub><mover accent="true"><mi>A</mi><mo>ˉ</mo></mover><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mover accent="true"><mi>L</mi><mo>ˉ</mo></mover><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(A_k|\\bar{A}_{k-1},\\bar{L}_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0701em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8201em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8201em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">L</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> (often logistic regression).</li><li>Calculate weights for each individual and time point.</li><li><strong>Weighted estimation</strong>: Use these weights to create a pseudo-population in which treatment is randomized.</li></ul><p><strong>Key Outcome: Under correct assumptions, IP weighting &quot;removes&quot; confounding by simulating a situation where treatment/exposure is &quot;randomized&quot; with respect to confounders.</strong></p><hr><h3 id="c-estimation-of-causal-effects" tabindex="-1"><a class="header-anchor" href="#c-estimation-of-causal-effects"><span>C. Estimation of Causal Effects</span></a></h3><p>Main approach:</p><ul><li><strong>Estimate average outcome conditional on being in a treatment strategy</strong> via weighted average:<br> [<br> E^{ps}[Y|A=\\bar{a}] = \\frac{E[SW_{\\bar{A}} Y I(A=\\bar{a})]}{E[SW_{\\bar{A}} I(A=\\bar{a})]}<br> ]</li></ul><p><strong>中文：</strong><br> [<br> E^{ps}[Y|A=\\bar{a}] = \\frac{E[SW_{\\bar{A}} Y I(A=\\bar{a})]}{E[SW_{\\bar{A}} I(A=\\bar{a})]}<br> ]</p><p>For the causal effect:<br> [<br> E^{ps}[Y|A=\\bar{a}] - E^{ps}[Y|A=\\bar{a}&#39;]<br> ]</p><hr><h3 id="d-technical-points" tabindex="-1"><a class="header-anchor" href="#d-technical-points"><span>D. Technical Points</span></a></h3><ul><li>In <strong>dynamic treatments</strong>, stabilized weights no longer work and nonstabilized weights are required (<strong>Technical Point 21.2</strong>).</li><li>For dynamic strategies: only the denominator of the weight is used; numerator isn’t well-defined.</li><li>Model misspecification in either weights or g-formula can produce bias; comparing both approaches is a robustness check.</li><li><strong>Marginal structural mean models</strong> (e.g., <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">[</mo><msub><mi>Y</mi><mover accent="true"><mi>a</mi><mo>ˉ</mo></mover></msub><mo stretchy="false">]</mo><mo>=</mo><msub><mi>β</mi><mn>0</mn></msub><mo>+</mo><msub><mi>β</mi><mn>1</mn></msub><mi mathvariant="normal">cum</mi><mo>⁡</mo><mo stretchy="false">(</mo><mover accent="true"><mi>a</mi><mo>ˉ</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E[Y_{\\bar{a}}]=\\beta_0+\\beta_1 \\operatorname{cum}(\\bar{a})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2474em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5678em;"><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord mathnormal mtight">a</span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord mtight">ˉ</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0528em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0528em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mord mathrm">cum</span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5678em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">a</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>) are used to reduce model complexity and to estimate overall causal effect.</li></ul><hr><h3 id="e-censoring-as-a-time-varying-treatment" tabindex="-1"><a class="header-anchor" href="#e-censoring-as-a-time-varying-treatment"><span>E. Censoring as a Time-Varying Treatment</span></a></h3><p>When dealing with right-censoring (loss to follow-up), treat censoring as time-varying &quot;treatment&quot; variables <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>C</mi><mrow><mi>K</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">C_1, ..., C_{K+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span> (0 = not censored, 1 = censored).</p><p>Update g-formula and weights:</p>',17),s("p",null,[a("["),s("br"),a(" W_{\\bar{C}} = \\prod_{k=1}^{K+1} \\frac{1}{P(C_k=0|C_{k-1}=0, \\bar{A}"),s("em",{"k-1":""},"{k-1},\\bar{L}"),a(")}"),s("br"),a(" ]")],-1),s("p",null,[a("["),s("br"),a(" \\begin{align*}"),s("br"),a(" \\text{G-formula with censoring: } & \\"),s("br"),a(" E[Y_{\\bar{a}, \\bar{c}=0}] &= \\sum_{\\bar{l}} E[Y | \\bar{C} = 0, \\bar{A}=\\bar{a}, \\bar{L} = \\bar{l}] \\prod_{k=0}^K f(l_k | c_k = 0, \\bar{a}"),s("em",{"k-1":""},"{k-1}, \\bar{l}"),a(")"),s("br"),a(" \\end{align*}"),s("br"),a(" ]")],-1),s("p",null,[s("strong",null,"中文：")],-1),s("p",null,[a("["),s("br"),a(" W_{\\bar{C}} = \\prod_{k=1}^{K+1} \\frac{1}{P(C_k = 0 | C_{k-1}=0, \\bar{A}"),s("em",{"k-1":""},"{k-1}, \\bar{L}"),a(")}"),s("br"),a(" ]")],-1),s("p",null,[a("带删失的g公式："),s("br"),a(" ["),s("br"),a(" E[Y_{\\bar{a}, \\bar{c}=0}] = \\sum_{\\bar{l}} E[Y | \\bar{C} = 0, \\bar{A} = \\bar{a}, \\bar{L} = \\bar{l}] \\prod_{k=0}^K P(L_k | c_k=0, \\bar{A}"),s("em",{"k-1":""},"{k-1}, \\bar{L}"),a(")"),s("br"),a(" ]")],-1),n('<p>Censoring IP weights, when used, create a pseudo-population with no censoring.</p><hr><h2 id="_5-doubly-robust-and-multiply-robust-estimation" tabindex="-1"><a class="header-anchor" href="#_5-doubly-robust-and-multiply-robust-estimation"><span>5. Doubly Robust and Multiply Robust Estimation</span></a></h2><h3 id="a-doubly-robust-dr-estimator" tabindex="-1"><a class="header-anchor" href="#a-doubly-robust-dr-estimator"><span>A. Doubly Robust (DR) Estimator</span></a></h3><h4 id="for-time-fixed-treatment" tabindex="-1"><a class="header-anchor" href="#for-time-fixed-treatment"><span>For Time-Fixed Treatment</span></a></h4><p>Given</p><ul><li>Treatment model: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>f</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>A</mi><mi mathvariant="normal">∣</mi><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\hat{f}(A|L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2079em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9579em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.0833em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord">∣</span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span></li><li>Outcome model: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>E</mi><mo>^</mo></mover><mo stretchy="false">[</mo><mi>Y</mi><mi mathvariant="normal">∣</mi><mi>A</mi><mo separator="true">,</mo><mi>L</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\\hat{E}[Y|A, L]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1968em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9468em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord">∣</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span><span class="mclose">]</span></span></span></span></li></ul><p>Estimator for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">[</mo><msup><mi>Y</mi><mi>a</mi></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">E[Y^a]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>:<br> [<br> \\hat{E}[Y^a] = \\frac{1}{n} \\sum_{i=1}^n \\hat{E}[Y|A=a, L_i] + \\frac{I(A_i = a)}{\\hat{f}(a | L_i)} (Y_i - \\hat{E}[Y|A=a, L_i])<br> ]</p><p><strong>中文：</strong><br> [<br> \\hat{E}[Y^a] = \\frac{1}{n} \\sum_{i=1}^n \\left[ \\hat{E}[Y|A=a, L_i] + \\frac{I(A_i = a)}{\\hat{f}(a | L_i)} (Y_i - \\hat{E}[Y|A=a, L_i]) \\right]<br> ]</p><p><strong>Key property:</strong> Consistent if either the treatment model <strong>or</strong> the outcome model is correct.</p><hr><h4 id="for-time-varying-treatments-bang-robins-2005-tmle" tabindex="-1"><a class="header-anchor" href="#for-time-varying-treatments-bang-robins-2005-tmle"><span>For Time-Varying Treatments (Bang &amp; Robins 2005, TMLE):</span></a></h4><ul><li>Sequentially fit treatment and outcome models at each time.</li><li>Construct weights and sequential outcome fits.</li><li>The estimator is <strong>doubly robust</strong> (consistent if at least one set of models is correct), and, under certain algorithms/combinations, even <strong>multiply robust</strong> (consistent in a broader range of scenarios, e.g., if correct for some subset of times).</li></ul><p>See <strong>Technical Point 21.4/21.5/21.6</strong> for the &quot;K+2&quot;-robust and &quot;2K+1&quot;-robust estimators.</p><hr><h4 id="multiply-robust-estimation-technical-points-21-4–21-6" tabindex="-1"><a class="header-anchor" href="#multiply-robust-estimation-technical-points-21-4–21-6"><span>Multiply Robust Estimation (Technical Points 21.4–21.6):</span></a></h4><ul><li>Estimators exist (e.g., TMLE) that are consistent if at least any one of several model blocks (either for outcome or treatment at any time) are correct.</li><li>In practice, fits involve iterated regression and reweighting.</li></ul><hr><h2 id="_6-g-estimation-for-time-varying-treatments" tabindex="-1"><a class="header-anchor" href="#_6-g-estimation-for-time-varying-treatments"><span>6. G-Estimation for Time-Varying Treatments</span></a></h2><h3 id="a-structural-nested-mean-models-snmm" tabindex="-1"><a class="header-anchor" href="#a-structural-nested-mean-models-snmm"><span>A. Structural Nested Mean Models (SNMM)</span></a></h3><ul><li>For each time <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>, define &quot;blip&quot; functions <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>γ</mi><mi>k</mi></msub><mo stretchy="false">(</mo><msub><mi>a</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>l</mi><mi>k</mi></msub><mo separator="true">,</mo><mi>β</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\gamma_k(a_{k-1}, l_k, \\beta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mclose">)</span></span></span></span> for causal effect of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">A_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> at level <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a_k=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>.</li><li>The observed data is related to counterfactual outcomes via:</li></ul><p>[<br> Y_{a_0,0} = Y_{0,0} + \\psi_0 a_0<br> ]<br> [<br> Y_{a_0,a_1} = Y_{a_0,0} + \\psi_{11} a_1 + \\psi_{12} a_1 L_{a_0,1} + \\psi_{13} a_1 a_0 + \\psi_{14} a_1 a_0 L_{a_0,1}<br> ]</p><p><strong>Estimation Strategy</strong> (G-Estimation):</p><ul><li>Use observed data to construct candidate &quot;blip-adjusted&quot; outcomes <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>k</mi></msub><mo stretchy="false">(</mo><msup><mi>ψ</mi><mo>†</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H_k (\\psi^\\dagger)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">†</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</li><li>Solve estimating equations (via regression): the g-estimate <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>ψ</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\\hat{\\psi}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1523em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9579em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1389em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span></span></span></span> is the value for which <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>k</mi></msub><mo stretchy="false">(</mo><msup><mi>ψ</mi><mo>†</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H_k(\\psi^\\dagger)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">†</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> yields no dependence of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">A_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>k</mi></msub><mo stretchy="false">(</mo><msup><mi>ψ</mi><mo>†</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H_k(\\psi^\\dagger)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">†</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, conditional on prior history.</li></ul><p><strong>For multiple time points:</strong></p><ul><li>General form:<br> [<br> E[Y_{a_{k-1}, a_k, 0_{k+1}} - Y_{a_{k-1}, 0_k} | L_{a_{k-1},k} = l_k, A_{k-1} = a_{k-1}, A_k = a_k ] = a_k \\gamma_k(a_{k-1}, l_k, \\beta)<br> ]</li></ul><p><strong>Key property:</strong> G-Estimation avoids certain null paradoxes of the g-formula; more efficient than IP weighting when model specified correctly, but more sensitive to model misspecification.</p><hr><h4 id="relationship-to-marginal-structural-models-technical-point-21-7" tabindex="-1"><a class="header-anchor" href="#relationship-to-marginal-structural-models-technical-point-21-7"><span>Relationship to Marginal Structural Models (Technical Point 21.7):</span></a></h4><ul><li>SNMM becomes a marginal structural mean model (MSM) if effect modification by past covariate history is absent.</li><li>G-estimation and IP weighting are dual under MSM, but g-estimation more efficient if the SNMM is correct.</li></ul><hr><h3 id="b-simulation-for-dynamic-regimes-technical-point-21-9" tabindex="-1"><a class="header-anchor" href="#b-simulation-for-dynamic-regimes-technical-point-21-9"><span>B. Simulation for Dynamic Regimes (Technical Point 21.9)</span></a></h3><ul><li>After estimating blips, can simulate outcomes under dynamic strategies by <ol><li>Simulating histores of confounders under the strategy,</li><li>Applying the estimated blip effects.</li></ol></li></ul><hr><h2 id="_7-the-g-null-paradox-technical-point-21-3" tabindex="-1"><a class="header-anchor" href="#_7-the-g-null-paradox-technical-point-21-3"><span>7. The G-Null Paradox (Technical Point 21.3)</span></a></h2><ul><li><strong>Parametric g-formula</strong> can yield <em>spurious effects</em> under the null if models for each component are misspecified, despite no true treatment effect.</li><li><strong>IPW and g-estimation methods</strong> do not suffer from this paradox under the sharp null (no treatment effect for any subject).</li></ul><hr><h2 id="_8-the-big-g-formula" tabindex="-1"><a class="header-anchor" href="#_8-the-big-g-formula"><span>8. The Big G-Formula</span></a></h2><h3 id="key-concept" tabindex="-1"><a class="header-anchor" href="#key-concept"><span>Key Concept</span></a></h3><ul><li>If all variables (measured and unmeasured) that are parents of treatment are included, the g-formula based on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>L</mi><mo separator="true">,</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A, L, U)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span> will identify the counterfactual mean for any regime.</li><li>In practice, unmeasured confounders (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>) can&#39;t be included, so question reduces to: <em>can the g-formula be written as a function of observed data only?</em> (i.e., is the effect <strong>identifiable</strong>).</li><li>The <strong>front-door formula</strong> is an example: under certain DAG conditions, the effect is identifiable even when unmeasured confounding exists, via mediators.</li></ul><p><strong>Formal Expression (see Technical Point 21.11):</strong><br> [<br> E[Y^a] = \\sum_m P(M=m|A=a) \\sum_{a&#39;} E[Y|M=m, A=a&#39;] P(A=a&#39;)<br> ]</p><p><strong>中文：</strong><br> [<br> E[Y^a] = \\sum_m P(M=m|A=a) \\sum_{a&#39;} E[Y|M=m, A=a&#39;] P(A=a&#39;)<br> ]</p><ul><li>General results by Tian &amp; Pearl, Shpitser &amp; Pearl: If identification is possible, there <em>exists</em> such a formula.</li></ul><hr><h2 id="_9-formal-definition-of-general-snmm-technical-point-21-13" tabindex="-1"><a class="header-anchor" href="#_9-formal-definition-of-general-snmm-technical-point-21-13"><span>9. Formal Definition of General SNMM (Technical Point 21.13)</span></a></h2><ul><li><p>The SNMM can be defined relative to any strategy <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>.</p></li><li><p>The blip function:<br> [<br> \\gamma_t^g(a_t, l_t) = E[Y_{a_{t-1}, a_t, g_{t+1}} - Y_{a_{t-1}, g_t, g_{t+1}} | A_{t-1} = a_{t-1}, A_t = a_t, L_t = l_t]<br> ]</p></li><li><p>Additive SNMMs allow for optimal regime identification (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mtext>opt</mtext></msub><mo>=</mo><mi>arg</mi><mo>⁡</mo><msub><mrow><mi>max</mi><mo>⁡</mo></mrow><mi>g</mi></msub><mi>E</mi><mo stretchy="false">[</mo><msub><mi>Y</mi><mi>g</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">g_{\\text{opt}} = \\arg\\max_g E[Y_g]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">opt</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mop">ar<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop">max</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>).</p></li></ul><hr><h1 id="总结精要-中文" tabindex="-1"><a class="header-anchor" href="#总结精要-中文"><span>总结精要（中文）</span></a></h1><h3 id="核心内容" tabindex="-1"><a class="header-anchor" href="#核心内容"><span>核心内容</span></a></h3><ul><li><strong>时间变化处理下传统混杂矫正方法失效，需要g方法（g-formula, IPW, g-estimation）</strong></li><li>g方法依赖“序列交换性、正则性（positivity）、一致性”三大可识别条件</li><li>各种方法可通过参数模型、插件法实现，需注意模型不正确时的偏倚</li><li>可以构造双（多）重鲁棒法（即可兼容模型部分错配）</li><li>删失（丢失访问）需看作也是时间变化的处理，g方法适用，只需权重或g公式加入删失概率</li><li>&quot;big g-formula&quot;说明理论上只要所有父节点（测量和未测量）都在g公式里，总是可识别，但实际没法访问未测量变量，是否仅用观测变量可识别由d分离判别</li></ul><h3 id="技术结论" tabindex="-1"><a class="header-anchor" href="#技术结论"><span>技术结论</span></a></h3><ul><li>只要观测到所有混杂、满足可识别条件，g-formula、IPW和g-estimation结果应等价</li><li>g-estimation在正确模型下效率更高，IP加权较稳健，对模型偏差更不敏感</li><li>g公式组件可无单独因果意义，但整体在随机试验下有；IP权重直接描述逆概率下的伪人群</li><li>复杂模型（高度维度）可用顺序回归、插件、机器学习等实现多重鲁棒</li><li>censoring（删失）看作是与A一样的处理变量，统一用g方法解决</li></ul><hr><h2 id="参考公式列表" tabindex="-1"><a class="header-anchor" href="#参考公式列表"><span>参考公式列表</span></a></h2><p><strong>1. g-公式（静态/动态策略）：</strong></p>',55),s("p",null,[a("["),s("br"),a(" E[Y_{\\bar{a}}] = \\sum_{\\bar{l}} E[Y|\\bar{A} = \\bar{a}, \\bar{L} = \\bar{l}] \\prod_{k=0}^K f(l_k | \\bar{a}"),s("em",{"k-1":""},"{k-1}, \\bar{l}"),a(")"),s("br"),a(" ]")],-1),s("p",null,[s("strong",null,"2. IP权重：")],-1),s("p",null,[a("["),s("br"),a(" W_{\\bar{A}} = \\prod_{k=0}^K \\frac{1}{f(A_k|\\bar{A}_{k-1}, \\bar{L}_k)}"),s("br"),a(" ]")],-1),s("p",null,[a("["),s("br"),a(" SW_{\\bar{A}} = \\prod_{k=0}^K \\frac{f(A_k|\\bar{A}"),s("em",{"k-1":""},"{k-1})}{f(A_k|\\bar{A}"),a(", \\bar{L}_k)}"),s("br"),a(" ]")],-1),n('<p><strong>3. 双鲁棒估计量示例：</strong></p><p>[<br> \\hat{E}[Y^a] = \\frac{1}{n}\\sum_{i=1}^n \\hat{E}[Y|A=a, L_i] + \\frac{I(A_i = a)}{\\hat{f}(a | L_i)} (Y_i - \\hat{E}[Y|A=a, L_i])<br> ]</p><p><strong>4. SNMM &amp; G-Estimation:</strong></p><p>[<br> E[Y_{a_{k-1}, a_k, 0_{k+1}} - Y_{a_{k-1}, 0_k} | L_{a_{k-1},k} = l_k, A_{k-1} = a_{k-1}, A_k = a_k ] = a_k \\gamma_k(a_{k-1}, l_k, \\beta)<br> ]</p><hr><h2 id="最后建议" tabindex="-1"><a class="header-anchor" href="#最后建议"><span>最后建议</span></a></h2><ul><li><strong>如估计结果有显著差异，应检查所有模型，防止系统性偏差。</strong></li><li><strong>推荐多种方法并行实现，包含多种模型、鲁棒性加强。</strong></li><li><strong>遇到删失数据，要系统地将其纳入g方法权重处理。</strong></li></ul><hr><p><em>This summary preserves all crucial technical points, formulas, and logical structure from the chapter, with bilingual formula expression as requested. For specific implementation or program code (e.g. R or SAS packages), refer to indicated software.</em></p>',9)])])}const h=e(i,[["render",m]]),g=JSON.parse(`{"path":"/posts/Causal%20inference/What-if%20book%20reading%20notes/response_md/gpt-4.1/Chapter_21.html","title":"Chapter_21","lang":"en-US","frontmatter":{"title":"Chapter_21","category":"Causal inference","tags":["gpt-4.1","response_md"],"description":"Chapter 21: G-Methods for Time-Varying Treatments（时间变化处理的g方法） This chapter provides a comprehensive overview of three main g-methods—the g-formula, IP weighting, and g-estimatio...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Chapter_21\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-17T03:19:05.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Aaron L\\",\\"url\\":\\"https://aaronlzm.github.io\\",\\"email\\":\\"lzm_aaron@outlook.com\\"}]}"],["meta",{"property":"og:url","content":"https://aaronlzm.github.io/posts/Causal%20inference/What-if%20book%20reading%20notes/response_md/gpt-4.1/Chapter_21.html"}],["meta",{"property":"og:site_name","content":"Aaron's Blog"}],["meta",{"property":"og:title","content":"Chapter_21"}],["meta",{"property":"og:description","content":"Chapter 21: G-Methods for Time-Varying Treatments（时间变化处理的g方法） This chapter provides a comprehensive overview of three main g-methods—the g-formula, IP weighting, and g-estimatio..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-09-17T03:19:05.000Z"}],["meta",{"property":"article:tag","content":"response_md"}],["meta",{"property":"article:tag","content":"gpt-4.1"}],["meta",{"property":"article:modified_time","content":"2025-09-17T03:19:05.000Z"}]]},"git":{"createdTime":1758079145000,"updatedTime":1758079145000,"contributors":[{"name":"lizhimou","username":"lizhimou","email":"lizhimou@bytedance.com","commits":1,"url":"https://github.com/lizhimou"}]},"readingTime":{"minutes":9.05,"words":2715},"filePathRelative":"posts/Causal inference/What-if book reading notes/response_md/gpt-4.1/Chapter_21.md","excerpt":"\\n<p>This chapter provides a comprehensive overview of three main g-methods—<strong>the g-formula</strong>, <strong>IP weighting</strong>, and <strong>g-estimation</strong>—and their doubly/multiply robust extensions for estimating causal effects in the presence of time-varying treatments with treatment-confounder feedback. The chapter also addresses the issue of censoring as a time-varying process and generalizes the notion of identification through the \\"big g-formula\\". Below, I summarize all technical, fine, and key points, and provide main formulas in both English and Chinese with standard LaTeX math formatting.</p>","autoDesc":true}`);export{h as comp,g as data};
